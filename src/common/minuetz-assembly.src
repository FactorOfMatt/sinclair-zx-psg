; minuetz assembly code + tables

                processor z80

; constants
nonote          equ 0
count           equ 1
partcount       equ 2
dice_count      equ 2
ink0            equ 0
opcode_ld_b     equ 6
slotcount       equ 6
ink7            equ 7
barcount        equ 8
sidecount       equ 10
barstep         equ 18 ; $12
count3          equ 20
facestep        equ 42 ; $2a
topnote         equ 51 ; 
nonote_69       equ 69 ; not sure
count1          equ 121
opcode_ret      equ 201
count2          equ 255
countp          equ 255
rhplotcords     equ 80 * 256 + 140
lhplotcords     equ 104 * 256 + 4
scrnsize        equ 2 * 256 + 192

; addresses
; regaddr         equ 221 ; $dd
; regout          equ 223 ; $df
rombeep         equ 1016; $03f8 - ROM beep routine?
setprtpos       equ 3545; $0dd9 - ROM AT routine?
draw            equ 9402; $24ba - ROM draw routine?
stkacc          equ 11560; $2d28 - ROM stack accumulator routine?
att_minus_file  equ 22528 ; $5800 - attributes?
plotxy          equ 23677 ; $5c7d - somewhere in "system variables"

;                org 23755 ; guessing...
;
;                incbin "build/minuetz-basic.bin"
;
                org 28930

                ; generated by bartab.c and $(BUILD)/bartab
                include "bartab.src"

                ; 31414
notetable       dc.b   0,   0   ; ! 
                                ;       freq = 2000000/(16 * period)
                dc.b 148,   6   ; "  1  1684  -> 74 Hz
                dc.b  42,   6   ; #  1  1572  -> 79 Hz
                dc.b 210,   5   ; $  1  1490  -> 84 Hz
                dc.b 126,   5   ; %  1
                dc.b  47,   5   ; &  1
                dc.b 229,   4   ; '  1
                dc.b 158,   4   ; (  1
                dc.b  92,   4   ; )  1
                dc.b  29,   4   ; *  1
                dc.b 226,   3   ; +  1
                dc.b 171,   3   ; ,  1
                dc.b 118,   3   ; -  1

                dc.b  68,   3   ; .  2  836 -> 150Hz
                dc.b  21,   3   ; /  2  789 -> 158Hz
                dc.b 233,   2   ; 0  2  745 -> 168Hz
                dc.b 191,   2   ; 1  2
                dc.b 152,   2   ; 2  2
                dc.b 114,   2   ; 3  2
                dc.b  79,   2   ; 4  2
                dc.b  46,   2   ; 5  2
                dc.b 15,    2   ; 6  2
                dc.b 241,   1   ; 7  2
                dc.b 213,   1   ; 8  2
                dc.b 177,   1   ; 9  2

                dc.b 162,   1   ; :  3  418 -> 300Hz  c
                dc.b 139,   1   ; ;  3  395 -> 316Hz  c#
                dc.b 116,   1   ; <  3  372 -> 336Hz  d
                dc.b  96,   1   ; =  3  352 -> 355Hz  d#
                dc.b  76,   1   ; >  3                e
                dc.b  57,   1   ; ?  3                f
                dc.b  40,   1   ; @  3                f#
                dc.b  23,   1   ; A  3                g   <- this is about where A440 ends up at 2Mhz
                dc.b   7,   1   ; B  3                g#
                dc.b 249,   0   ; C  3 249 -> 502Hz   a
                dc.b 235,   0   ; D  3                a#
                dc.b 221,   0   ; E  3                b

                dc.b 209,   0   ; F  4  209 -> 598Hz
                dc.b 197,   0   ; G  4  197 -> 635Hz
                dc.b 186,   0   ; H  4  186 -> 672Hz
                dc.b 176,   0   ; I  4
                dc.b 166,   0   ; J  4
                dc.b 157,   0   ; K  4
                dc.b 148,   0   ; L  4
                dc.b 140,   0   ; M  4
                dc.b 132,   0   ; N  4
                dc.b 126,   0   ; O  4
                dc.b 117,   0   ; P  4

                dc.b 111,   0   ; Q  5  111 -> 1126Hz
                dc.b 105,   0   ; R  5  105 -> 1190Hz
                dc.b  99,   0   ; S  5  99  -> 1263Hz
                dc.b  93,   0   ; T  5

                ; 31518
dicetables      dc.b  21,   6,  62,  36,  66,  85
                dc.b  39,  96,  34,   3,  12,  21
                dc.b   6,  62,  16,  66,  85,  39
                dc.b  47, 112,  75,  12, 111, 102
                dc.b 123,  91, 127,  25, 134,  92
                dc.b  38, 129,  10,  37,  56,  13
                dc.b  73,  41, 131,  49,  46, 122
                dc.b  54,  84,  86, 115, 119, 126
                dc.b  71, 120,  81, 110,  67, 107
                dc.b  26,  99,  42,  50,   2,  80
                dc.b  61, 105,  74, 103,  43,  33
                dc.b  11, 106,  90, 124,  32,  95
                dc.b  20, 133,  55, 116,  87,   5
                dc.b  29,   5,  29,   5,  29,   5
                dc.b  29,   5,  29,   5,  63,  94
                dc.b  59,  78,  23, 108,  13,  97
                dc.b  58,  83,  31,  98,  35, 109
                dc.b 138, 113,  64, 121,  76,  69
                dc.b   4,  19,  24, 101,  14,   7
                dc.b  57, 118,  45,  44,  18,  28
                dc.b  88,   9,  51, 104,  30, 100
                dc.b  27, 137, 130,  72, 128,  79
                dc.b  45, 136,  52,  60,  68,  82
                dc.b  39,  47,  34,  53,  12,  45
                dc.b  17,  52, 125,  66,  82, 132
                dc.b  47,  34,  53,  12,  89,  93
                dc.b 114,  48,   1,  22,  77,  65
                dc.b 117, 135,  40,   8,   8,   8
                dc.b   8,   8,   8,   8,  70,  70
                dc.b  70,   8



                ; 31694
drawdicedata1   dc.b 17, 26, 16, 31, 18, 21
                dc.b 16, 31, 17, 26, 18, 21
                dc.b 16, 31, 20, 27, 18, 21
                dc.b 14, 25, 16, 31, 20, 27
                dc.b 18, 21, 14, 25, 17, 26
                dc.b 16, 31, 18, 29, 20, 27
                dc.b 18, 21, 16, 23, 14, 25
                dc.b 11, 29, 10, 32, 11, 26
                dc.b 10, 32, 11, 29, 11, 26
                dc.b 10, 32, 14, 32, 11, 26
                dc.b  7, 26, 10, 32, 14, 32
                dc.b 11, 26,  7, 26, 11, 29
                dc.b 10, 32, 12, 32, 14, 32
                dc.b 11, 26,  9, 26,  7, 26
                dc.b 12, 22,  8, 24, 16, 20
                dc.b  8, 24, 16, 20, 12, 22
                dc.b  8, 24, 12, 24, 16, 20
                dc.b 12, 20,  8, 24, 12, 24
                dc.b 16, 20, 12, 20, 12, 22
                dc.b  8, 24, 10, 24, 12, 24
                dc.b 16, 20, 14, 20, 12, 20
                dc.b 14,  9, 13, 14, 15,  4
                dc.b 13, 14, 14,  9, 15,  4
                dc.b 13, 14, 17, 10, 15,  4
                dc.b 11,  8, 13, 14, 17, 10
                dc.b 15,  4, 11,  8, 14,  9
                dc.b 13, 14, 15, 12, 17, 10
                dc.b 15,  4, 13,  6, 11,  8
                dc.b  8, 12,  7, 15,  8,  9
                dc.b  7, 15,  8,  9,  8, 12
                dc.b  7, 15, 11, 15,  8,  9
                dc.b  4,  9,  7, 15, 11, 15
                dc.b  8,  9,  4,  9,  8, 12
                dc.b  7, 15,  9, 15, 11, 15
                dc.b  8,  9,  6,  9,  4,  9
                dc.b  9,  5,  5,  7, 13,  3
                dc.b  5,  7, 13,  3,  9,  5
                dc.b  5,  7,  9,  7, 13,  3
                dc.b  9,  3,  5,  7,  9,  7
                dc.b 13,  3,  9,  3,  9,  5
                dc.b  5,  7,  7,  7,  9,  7
                dc.b 13,  3, 11,  3,  9,  3



                ; 31946
drawdicedata2   dc.b 5, 4, 6, 3, 6, 5
                dc.b 5, 1, 5, 6, 4, 1



                ; 31958
drawdicedata3   dc.b  47,  45,   1,   1,  65,  22
                dc.b   1, 255,  47,  47, 255, 255
                dc.b  65,  24, 255,   1,   0,  55
                dc.b   0, 255,  65,  25,   1, 255
                dc.b   0,  55,   0,   1,   0,  55
                dc.b   0, 255,  45,  45,   1,   1
                dc.b   0,  55,   0,   1



dicemain        subroutine  ; 31998
inkoff          ld (iy + 85),0
                ld hl,drawdicedata1
                ld a,(dicenosto)
                ld b, dice_count
nxtdice         push bc
                push hl
                push af
prtopface       call prtdots
                ld de,facestep
                pop af
                pop hl
                add hl,de
                push hl
                ld de,drawdicedata2 - 2
validnum        inc de
                inc de
                dec a
                jr nz,validnum
                ld a,(de)
                push de
prtlhface       call prtdots
                pop de
                inc de
                ld a,(de)
                ld de,facestep
                pop hl
                add hl,de
                push hl
                push de
prtrhface       call prtdots
                pop de
                pop hl
                add hl,de
                ld a,(rhdiceno) ; 58 150 125 - $3a $a0 $7d ($7da0 32160)
                pop bc
                djnz nxtdice
drawcubes       ld hl,rhplotcords ; 33 140 80 - $21 $8c $50 ($508c)
                ld (plotxy),hl ; 34 125 92 - $22 $7c $5c ($5c7c)
                call drawdice
                ld hl,lhplotcords ; 33 4 104 - $21 $04 $68 ($6804)
                ld (plotxy),hl ; 34 125 92 - $22 $7c $5c ($5c7c)
                call drawdice
inkon           ld (iy + 85),7
                ld hl,att_minus_file
                ld bc,scrnsize
.nxtposn        ld a,(hl)
                cp ink0
                jr nz,done_q
                ld (hl),ink7
done_q          dec bc
                inc hl
                ld a,b
                or c
                jr nz,.nxtposn
                ret



drawdice        subroutine ; 32100
saveret         exx
                push hl
                exx
                ld b,sidecount
                ld hl,drawdicedata3
nxtside         push bc
                ld c,(hl)
                inc hl
                ld b,(hl)
                inc hl
                ld e,(hl)
                inc hl
                ld d,(hl)
                inc hl
                push hl
                call draw ; 205 186 36 - $cd $ba $24  ($24ba)
                pop hl
                pop bc
                djnz nxtside
unstkret        exx
                pop hl
                exx
                ret



prtdots         subroutine ; 32129
getnum          ld b,a
                push bc
                xor a
                ld d,a
                ld e,a
getdotpat       add a,e
                inc e
                inc e
                djnz getdotpat
                ld e,a
                add hl,de
                pop bc
nxtdot          push bc
                ld b,(hl)
                inc hl
                ld c,(hl)
                inc hl
                push hl
                call setprtpos ; 205 217 13 - $cd $d9 $0d
                ld a, 'o
prtdot          rst $10
                pop hl
                pop bc
                djnz nxtdot
                ret

; 32159... what goes here?
dicenosto       dc.b 0 ; 32159 - $7d9f number of left hand dice
rhdiceno        dc.b 0 ; 32160 ; $7da0 number on right hand dice
voicesto        ds.b 48, 0 ; 32161 ; $7da1 48 values [6 notes * 4 bars * 2 rows]
rndtable        ds.b 16, 0 ; 32209 ; $7dd1 random table? 16 values (the dice-rolls?)
                          ; first half: 32209 - $7dd1  - lsb: 209 
                          ; second half: 32217 - $7dd9 - msb : 217
                          ; BASIC manipulates pointers into voicesto and rndtable depending on
                          ; voice and part

                ; 32225 - 51 bytes
                ; convert note to display index (accidentals share same index)
nattable        dc.b  1,  1,  2,  2,  3,  4
                dc.b  4,  5,  5,  6,  6,  7
                dc.b  8,  8,  9,  9, 10, 11
                dc.b 11, 12, 12, 13, 13, 14
                dc.b 15, 15, 16, 16, 17, 18
                dc.b 18, 19, 19, 20, 20, 21
                dc.b 22, 22, 23, 23, 25, 25
                dc.b 25, 26, 26, 27, 27, 28
                dc.b 29, 29, 30

notesort        subroutine ; 32276
                ld de,voicesto ; eventual output array of adjusted notes (accidentals are +128)
                push de
smc_rndtablo    ld hl,rndtable ; address of random number table [gets adjusted by self modifying code :( ]
                ld b,barcount ; 8 bars per 'part'
.nxtbar         push bc ; save the bar count
                ld b,(hl) ; get the next random number
                inc hl ; next random entry for next time
                push hl ; save random number pointer
                push de ; save output position
smc_bartablo    ld hl, bartable - 18 ; address of the bar-table offset by 0-2 depending on voice [self modified :( ]
                ld de,barstep ; we skip 18 bytes per bar
getbar          add hl,de ; point hl to next par
                djnz getbar ; loop for 'b' entries.  DE now points to the bar data we're interested in
                pop de ; get back the output pointer
                ld b,slotcount ; 6 - number of notes
.nxtslot        ld a,(hl) ; grab the note from the bar
                inc hl
                inc hl
                inc hl ; point to next note for later
                ld (de),a ; save the note in the output
                inc de ; next output location
                djnz .nxtslot ; do all 6 notes this bar
                pop hl ; get back the random number pointer
                pop bc ; get back the bar counter
                djnz .nxtbar ; process the next bar
                pop hl ; start of output into hl (pushed as de)
                ;
                ; smc_notesortend gets replaced with a ret if we are using the beeper
                ; which means that accidentals don't get 128 added to them for the beeper code - even though
                ; that's only for display purposes?
                ; 
smc_notesortend ld b,barcount*slotcount ; notecount: 48 .. 6 notes * 8 bars?
.nxtslot_1      push bc ; save the note-count
                ld a,(hl) ; get the saved note 
                ld b,topnote ; load 51 into b - 51 is the highest note
note_q          cp b ; compare note with current note (51 down to 0)
                jr z,natequiv ; we have the note
                djnz note_q ; keep looking
                ld a,b ; load a with 0?
                ld (hl),a ; store a 0 in the output
                jr ptnxtslot ; done with this note
natequiv        ld de,nattable-1 ; get base address of the note-accidental table
getnat          inc de ; adjust to next entry
                djnz getnat ; until we've incremented it b times
                ld a,(de) ; grab the nat table entry
                ld (hl),a ; save in the output table
                dec de ; select the nat previous entry
                ld a,(de) ; fetch the previous nat entry
                cp (hl) ; is it the same as the previous entry
                jr nz,ptnxtslot ; it is not
                set 7,(hl) ; yet is is, set the high bit
ptnxtslot       inc hl ; next output note
                pop bc ; restore bc (note count)
                djnz .nxtslot_1 ; do the next note
                ret


    ; the main ay-3-8910 play loop
playmain        subroutine ; 32350
                ld b,partcount ; play both parts
                push bc ; save part count
repeat          push bc ; save part count a second time
                ld b,barcount ; 8 bars
smc_rnd_low     ld de,rndtable ; fetch address of random number table
.nxtbar         push bc ; save bar count
                ld a,(de) ; fetch the random number
                inc de ; point to next random number for next time
                push de ; save random number pointer
                ld b,a ; save random number in b
                ld hl,0 ; reset hl
                ld de,18 ; set de to number of bytes to skip per bar (18 = 3 voices * 6 notes)
calcbar         add hl,de ; increment hl...
                djnz calcbar ; ... by the random number
                ld bc,bartable-18 ; load bc with address of bartable - one bar (18 bytes)
                and a ; set flags?
                add hl,bc ; add bar offset (bartable + random * barsize)
                ld b,slotcount ; 6 notes per bar
.nxtslot        push bc ; save the note count
                call playslot ; play the note in (hl) - all 3 voices
                ld b,count1 ; modified directly by BASIC! - it adjusts the tempo!
.loop1          ld c,count2
.loop2          dec c
                jr nz,.loop2 ; inner delay
                djnz .loop1 ; outer delay - modified by tempo
                pop bc ; bring back the note count
                djnz .nxtslot ; play all 6 notes
                pop de ; bring back random number pointer
                pop bc ; bring back bar count
                djnz .nxtbar ; next bar
                ld b,count3
.loop3          ld c,count2
.loop4          dec c
                jr nz,.loop4 ; inner delay
                djnz .loop3 ; outer delay
                pop bc ; bring back part counter
                djnz repeat ; play each part twice?
                ld hl,smc_rnd_low + 1 ; address of random number table
                ld (hl),<rndtable + 8 ; update lsb to be 8 bytes in (for part 2)
                pop bc ; bring back outer part counter
                djnz repeat2 ; not done..
                ld (hl),<rndtable ; update lsb to be start of random number table
                ret ; all done
repeat2         push bc ; save the part number
                inc b ; increment it
                jr repeat ; play next part


playslot        subroutine ; 32427
                xor a  ; a = 0
nxtvoice        push af ; save af for later
                out (regaddr),a ; select voice 'a'
                xor a ; a = 0
                cp (hl) ; is the next note in the bar 0?
                jr nz,.getnote ; not 0 (aka making a sound)
                call out ; play lsb = 0
                xor a ; a = 0
                jr hiout ; play msb = 0
.getnote        ld b,(hl) ; get note into hl
                ld de,notetable ; start of notetable in de
calcnote        inc de
                inc de ; increment de by 2...
                djnz calcnote ; ...'b' times to point to correct lsb/msb
                ld a,(de) ; grab lsb
                inc de ; point to msb
                call out ; set lsb in PSG
                ld a,(de) ; grab msb
hiout           call out ; set msb in PSG
                inc hl ; next note
                pop af ; fetch back the register index
                cp 6 ; did we do them all?
                ret z ; yes
                jr nxtvoice ; no - do the next voice



out             subroutine ; 32465
                ld b,count 
.loop1          djnz .loop1 ; a short delay
                out (regout),a ; output a in selected register
                ld b,count
.loop2          djnz .loop2 ; another short delay
                pop bc ; really the return address
                pop af ; the af we've been saving
                inc a ; increment the register number
                out (regaddr),a ; set the register number for next time
                push af ; save the register number
                push bc ; put the return address back
                ld b,count 
.loop3          djnz .loop3 ; yet another short delay
                ret


        ; beeper version of play loop
musicbox        subroutine ; 32487
                ld b,2
.nxtpart        push bc
                ld a,<rndtable + 8 + 8
                and a
getpart         sub 8
                djnz getpart
                ld (smc_rndtablo + 1),a ; 50 25 126 - $32 $19 $7E - $7E19 (32281)
                call part
                pop bc
                djnz .nxtpart
                ld a,<rndtable
                ld (smc_rndtablo + 1),a
                ret



part            subroutine ; 32512
                ld hl,smc_notesortend ; 33 59 126 - $21 $3b $7e $7e3b (32315)
                ld (hl),opcode_ret ; self modifying code goodness
                push hl
                call notesort
                call beepout
                ld b,countp
.loop1          djnz .loop1
                call beepout
                pop hl
                ld (hl),opcode_ld_b ; self modifying code goodness
                ret



beepout         subroutine ; 32535
                ld hl,voicesto ; only play the melody note
                ld b,slotcount * barcount ; 6 notes * 8 bars
.nxtslot        push bc
                push hl
                rst $28

                dc.b 52  ; ($34 stack list of literals)
                dc.b 128 ; ($80)
                dc.b 47  ; ($2F)
                dc.b 0   ; ($00)
                dc.b 0   ; ($00)
                dc.b 20  ; ($14)
                dc.b 56  ; ($38 end of calc)

                pop hl ; 225 ($e1)
                ld a,(hl)
                inc hl
                cp nonote
                jr nz,note
                ld a,nonote_69
note            push hl
                call stkacc ; 205 40 45 - $cd $28 $2d $2d28 (11560)
                call rombeep ; 205 248 3 - $cd $f8 $03 $03f8 (1016)
                pop hl
                pop bc
                djnz .nxtslot
                ret



                mac check_addr ; {1=name} {2=value}
                if ({1} != {2})
                err "label ",{1}," is incorrect!  It should be ",{2}
                endif
                endm

                check_addr bartable     , 28930 ; to 31313
                check_addr notetable    , 31414 ; to 31517
                check_addr dicetables   , 31518 ; to 31693
                check_addr drawdicedata1, 31694 ; to 31997
                check_addr drawdicedata2, 31946 ; to 31957
                check_addr drawdicedata3, 31958 ; to 31997
                check_addr dicemain     , 31998 ; to 32099
                check_addr drawdice     , 32100 ; to 32128
                check_addr prtdots      , 32129 ; to 32158
                check_addr dicenosto    , 32159 ; to 32160
                check_addr voicesto     , 32161 ; to 32208
                check_addr rndtable     , 32209 ; to 32224
                check_addr nattable     , 32225 ; to 32275
                check_addr notesort     , 32276 ; to 32349
                check_addr playmain     , 32350 ; to 32426
                check_addr playslot     , 32427 ; to 32464
                check_addr out          , 32465 ; to 32486
                check_addr musicbox     , 32487 ; to 32511
                check_addr part         , 32512 ; to 32534
                check_addr beepout      , 32535 ; to 32570
